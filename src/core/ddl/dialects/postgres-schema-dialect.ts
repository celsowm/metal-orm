import { BaseSchemaDialect } from './base-schema-dialect.js';
import { deriveIndexName } from '../naming-strategy.js';
import { renderIndexColumns, createLiteralFormatter } from '../sql-writing.js';
import { ColumnDef, ForeignKeyReference } from '../../../schema/column.js';
import { IndexDef, TableDef } from '../../../schema/table.js';
import { ColumnDiff, DatabaseColumn, DatabaseTable } from '../schema-types.js';
import { DialectName } from '../schema-dialect.js';

/** PostgreSQL schema dialect implementation. */
export class PostgresSchemaDialect extends BaseSchemaDialect {
  readonly name: DialectName = 'postgres';

  private _literalFormatter = createLiteralFormatter({
    booleanTrue: 'TRUE',
    booleanFalse: 'FALSE',
  });

  get literalFormatter() {
    return this._literalFormatter;
  }

  quoteIdentifier(id: string): string {
    return `"${id}"`;
  }

  renderColumnType(column: ColumnDef): string {
    switch (column.type) {
      case 'INT':
      case 'INTEGER':
      case 'int':
      case 'integer':
        return 'integer';
      case 'BIGINT':
      case 'bigint':
        return 'bigint';
      case 'UUID':
      case 'uuid':
        return 'uuid';
      case 'BOOLEAN':
      case 'boolean':
        return 'boolean';
      case 'JSON':
      case 'json':
        return 'jsonb';
      case 'DECIMAL':
      case 'decimal':
        return column.args?.length ? `numeric(${column.args[0]}, ${column.args[1] ?? 0})` : 'numeric';
      case 'FLOAT':
      case 'float':
      case 'DOUBLE':
      case 'double':
        return 'double precision';
      case 'TIMESTAMPTZ':
      case 'timestamptz':
        return 'timestamptz';
      case 'TIMESTAMP':
      case 'timestamp':
        return 'timestamp';
      case 'DATE':
      case 'date':
        return 'date';
      case 'DATETIME':
      case 'datetime':
        return 'timestamp';
      case 'VARCHAR':
      case 'varchar':
        return column.args?.length ? `varchar(${column.args[0]})` : 'varchar';
      case 'TEXT':
      case 'text':
        return 'text';
      case 'ENUM':
      case 'enum':
        return 'text';
      case 'BINARY':
      case 'binary':
      case 'VARBINARY':
      case 'varbinary':
      case 'BLOB':
      case 'blob':
      case 'BYTEA':
      case 'bytea':
        return 'bytea';
      default:
        return String(column.type).toLowerCase();
    }
  }

  renderAutoIncrement(column: ColumnDef): string | undefined {
    if (!column.autoIncrement) return undefined;
    const strategy = column.generated === 'always' ? 'GENERATED ALWAYS' : 'GENERATED BY DEFAULT';
    return `${strategy} AS IDENTITY`;
  }

  renderIndex(table: TableDef, index: IndexDef): string {
    const name = index.name || deriveIndexName(table, index);
    const cols = renderIndexColumns(this, index.columns);
    const unique = index.unique ? 'UNIQUE ' : '';
    const where = index.where ? ` WHERE ${index.where}` : '';
    return `CREATE ${unique}INDEX IF NOT EXISTS ${this.quoteIdentifier(name)} ON ${this.formatTableName(table)} (${cols})${where};`;
  }

  supportsPartialIndexes(): boolean {
    return true;
  }

  protected renderReferenceSuffix(ref: ForeignKeyReference, _table: TableDef): string | undefined {
    void _table;
    if (ref.deferrable) {
      return 'DEFERRABLE INITIALLY DEFERRED';
    }
    return undefined;
  }

  dropColumnSql(table: DatabaseTable, column: string): string[] {
    return [`ALTER TABLE ${this.formatTableName(table)} DROP COLUMN ${this.quoteIdentifier(column)};`];
  }

  dropIndexSql(table: DatabaseTable, index: string): string[] {
    const qualified = table.schema
      ? `${this.quoteIdentifier(table.schema)}.${this.quoteIdentifier(index)}`
      : this.quoteIdentifier(index);
    return [`DROP INDEX IF EXISTS ${qualified};`];
  }

  alterColumnSql(table: TableDef, column: ColumnDef, actualColumn: DatabaseColumn, diff: ColumnDiff): string[] {
    void actualColumn;
    const stmts: string[] = [];
    const tableName = this.formatTableName(table);
    const colName = this.quoteIdentifier(column.name);

    if (diff.typeChanged) {
      stmts.push(`ALTER TABLE ${tableName} ALTER COLUMN ${colName} TYPE ${this.renderColumnType(column)};`);
    }
    if (diff.defaultChanged) {
      if (column.default === undefined) {
        stmts.push(`ALTER TABLE ${tableName} ALTER COLUMN ${colName} DROP DEFAULT;`);
      } else {
        stmts.push(
          `ALTER TABLE ${tableName} ALTER COLUMN ${colName} SET DEFAULT ${this.renderDefault(column.default, column)};`
        );
      }
    }
    if (diff.nullabilityChanged) {
      stmts.push(`ALTER TABLE ${tableName} ALTER COLUMN ${colName} ${column.notNull ? 'SET' : 'DROP'} NOT NULL;`);
    }
    if (diff.autoIncrementChanged) {
      if (column.autoIncrement) {
        const strategy = column.generated === 'always' ? 'ALWAYS' : 'BY DEFAULT';
        stmts.push(`ALTER TABLE ${tableName} ALTER COLUMN ${colName} ADD GENERATED ${strategy} AS IDENTITY;`);
      } else {
        stmts.push(`ALTER TABLE ${tableName} ALTER COLUMN ${colName} DROP IDENTITY IF EXISTS;`);
      }
    }
    return stmts;
  }

  warnAlterColumn(_table: TableDef, _column: ColumnDef, _actual: DatabaseColumn, diff: ColumnDiff): string | undefined {
    void _table;
    void _column;
    void _actual;
    if (diff.autoIncrementChanged) {
      return 'Altering identity properties may fail if an existing sequence is attached; verify generated column state.';
    }
    return undefined;
  }
}
