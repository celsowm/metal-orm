import { BaseSchemaDialect } from './base-schema-dialect.js';
import {
  deriveIndexName,
  renderIndexColumns,
  DialectName
} from '../schema-generator.js';
import { ColumnDef } from '../../../schema/column.js';
import { IndexDef, TableDef } from '../../../schema/table.js';
import { DatabaseTable } from '../schema-types.js';

export class PostgresSchemaDialect extends BaseSchemaDialect {
  name: DialectName = 'postgres';

  quoteIdentifier(id: string): string {
    return `"${id}"`;
  }

  renderColumnType(column: ColumnDef): string {
    switch (column.type) {
      case 'INT':
      case 'INTEGER':
      case 'int':
      case 'integer':
        return 'integer';
      case 'BIGINT':
      case 'bigint':
        return 'bigint';
      case 'UUID':
      case 'uuid':
        return 'uuid';
      case 'BOOLEAN':
      case 'boolean':
        return 'boolean';
      case 'JSON':
      case 'json':
        return 'jsonb';
      case 'DECIMAL':
      case 'decimal':
        return column.args?.length ? `numeric(${column.args[0]}, ${column.args[1] ?? 0})` : 'numeric';
      case 'FLOAT':
      case 'float':
      case 'DOUBLE':
      case 'double':
        return 'double precision';
      case 'TIMESTAMPTZ':
      case 'timestamptz':
        return 'timestamptz';
      case 'TIMESTAMP':
      case 'timestamp':
        return 'timestamp';
      case 'DATE':
      case 'date':
        return 'date';
      case 'DATETIME':
      case 'datetime':
        return 'timestamp';
      case 'VARCHAR':
      case 'varchar':
        return column.args?.length ? `varchar(${column.args[0]})` : 'varchar';
      case 'TEXT':
      case 'text':
        return 'text';
      case 'ENUM':
      case 'enum':
        return 'text';
      default:
        return String(column.type).toLowerCase();
    }
  }

  renderAutoIncrement(column: ColumnDef): string | undefined {
    if (!column.autoIncrement) return undefined;
    const strategy = column.generated === 'always' ? 'GENERATED ALWAYS' : 'GENERATED BY DEFAULT';
    return `${strategy} AS IDENTITY`;
  }

  renderIndex(table: TableDef, index: IndexDef): string {
    const name = index.name || deriveIndexName(table, index);
    const cols = renderIndexColumns(this, index.columns);
    const unique = index.unique ? 'UNIQUE ' : '';
    const where = index.where ? ` WHERE ${index.where}` : '';
    return `CREATE ${unique}INDEX IF NOT EXISTS ${this.quoteIdentifier(name)} ON ${this.formatTableName(table)} (${cols})${where};`;
  }

  supportsPartialIndexes(): boolean {
    return true;
  }

  dropColumnSql(table: DatabaseTable, column: string): string[] {
    return [`ALTER TABLE ${this.formatTableName(table)} DROP COLUMN ${this.quoteIdentifier(column)};`];
  }

  dropIndexSql(table: DatabaseTable, index: string): string[] {
    const qualified = table.schema
      ? `${this.quoteIdentifier(table.schema)}.${this.quoteIdentifier(index)}`
      : this.quoteIdentifier(index);
    return [`DROP INDEX IF EXISTS ${qualified};`];
  }
}
